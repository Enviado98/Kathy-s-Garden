<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kathy's Garden | Bioluminescent World</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000508; 
            font-family: 'Courier New', monospace;
        }

        /* UI Layer */
        #ui {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            color: #00f0ff;
            font-size: 1.5rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            margin: 0;
            text-shadow: 0 0 20px #00f0ff;
            opacity: 0.8;
        }

        p {
            color: #a060ff;
            font-size: 0.8rem;
            margin-top: 5px;
            opacity: 0.6;
            letter-spacing: 2px;
        }

        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00f0ff;
            font-size: 1.2rem;
            letter-spacing: 5px;
            animation: blink 1s infinite;
            z-index: 20;
        }

        @keyframes blink { 50% { opacity: 0.3; } }
    </style>
    
    <!-- Three.js Imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loader">NEURAL LINKING...</div>
    
    <div id="ui">
        <h1>Kathy's Garden</h1>
        <p>Bioluminescent Sector 07</p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- 1. CONFIGURACIÓN E INICIALIZACIÓN ---
        const config = {
            fogColor: 0x000810,
            neonCyan: 0x00f0ff,
            neonPurple: 0xaa00ff,
            neonGreen: 0x00ff88
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.fogColor);
        scene.fog = new THREE.FogExp2(config.fogColor, 0.035); // Niebla densa y oscura

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 3, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        // --- 2. GENERADOR DE TEXTURAS (CANVAS) ---
        // Truco Pro: Generamos la textura de "venas" con código para no cargar imágenes
        function createBioTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            // Fondo negro
            ctx.fillStyle = '#000000';
            ctx.fillRect(0,0,512,512);
            
            // Líneas brillantes (venas)
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#00ffff';
            
            for(let i=0; i<20; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random()*512, 0);
                ctx.bezierCurveTo(
                    Math.random()*512, 200, 
                    Math.random()*512, 400, 
                    Math.random()*512, 512
                );
                ctx.stroke();
            }
            return new THREE.CanvasTexture(canvas);
        }
        
        function createHoloPanelTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 256; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0, 240, 255, 0.1)';
            ctx.fillRect(10,10,236,236);
            ctx.strokeStyle = '#00f0ff';
            ctx.lineWidth = 4;
            ctx.strokeRect(10,10,236,236);
            
            // "Datos" ficticios
            ctx.fillStyle = '#00f0ff';
            for(let i=0; i<10; i++) {
                ctx.fillRect(30, 40 + i*20, Math.random()*150 + 20, 5);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const bioTexture = createBioTexture();
        const holoTexture = createHoloPanelTexture();

        // --- 3. CREACIÓN DEL MUNDO ---

        // A. SUELO (Terreno Alienígena)
        const groundGeo = new THREE.PlaneGeometry(100, 100, 64, 64);
        const posAttr = groundGeo.attributes.position;
        for(let i=0; i<posAttr.count; i++){
            const x = posAttr.getX(i);
            const y = posAttr.getY(i); // En PlaneGeometry es Y local, pero será Z en mundo
            // Ruido simple para montañas suaves
            const z = Math.sin(x*0.1) * Math.cos(y*0.1) * 2 + Math.random()*0.2;
            posAttr.setZ(i, z);
        }
        groundGeo.computeVertexNormals();
        
        const groundMat = new THREE.MeshStandardMaterial({ 
            color: 0x050510, 
            roughness: 0.6,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI/2;
        scene.add(ground);

        // B. ÁRBOLES GIGANTES (HONGOS DE AVATAR)
        function createGiantMushroom(x, z, scale) {
            const group = new THREE.Group();
            
            // Tronco (Curvo y brillante)
            const trunkGeo = new THREE.CylinderGeometry(0.5 * scale, 1.5 * scale, 10 * scale, 16, 4);
            // Deformar tronco (Curvearlo)
            const trunkPos = trunkGeo.attributes.position;
            for(let i=0; i<trunkPos.count; i++){
                const y = trunkPos.getY(i);
                if(y > 0) {
                    const angle = y * 0.1;
                    trunkPos.setX(i, trunkPos.getX(i) + Math.sin(angle) * 2);
                }
            }
            trunkGeo.computeVertexNormals();

            const trunkMat = new THREE.MeshStandardMaterial({
                color: 0x111122,
                emissive: config.neonCyan,
                emissiveMap: bioTexture,
                emissiveIntensity: 2,
                roughness: 0.4
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 5 * scale;
            group.add(trunk);

            // Sombrero del hongo (Glowing Underside)
            const capGeo = new THREE.LatheGeometry(
                [new THREE.Vector2(0,0), new THREE.Vector2(3*scale, -0.5*scale), new THREE.Vector2(4*scale, 1*scale), new THREE.Vector2(0, 2*scale)],
                16
            );
            const capMat = new THREE.MeshStandardMaterial({
                color: config.neonPurple,
                emissive: 0x4400aa,
                emissiveIntensity: 0.5,
                side: THREE.DoubleSide
            });
            const cap = new THREE.Mesh(capGeo, capMat);
            cap.position.y = 10 * scale;
            // Branquias brillantes debajo
            const gillsGeo = new THREE.CircleGeometry(3.8 * scale, 32);
            const gillsMat = new THREE.MeshBasicMaterial({
                color: config.neonCyan,
                map: bioTexture,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const gills = new THREE.Mesh(gillsGeo, gillsMat);
            gills.rotation.x = Math.PI/2;
            gills.position.y = 9.5 * scale;
            
            group.add(cap);
            group.add(gills);
            
            group.position.set(x, -1, z);
            scene.add(group);
        }

        // Crear bosque
        createGiantMushroom(0, -10, 1.2); // Héroe central
        createGiantMushroom(-15, -20, 0.8);
        createGiantMushroom(15, -25, 0.9);
        createGiantMushroom(-8, 10, 0.6);
        createGiantMushroom(12, 5, 0.7);


        // C. VEGETACIÓN DE SUELO (Instancing para rendimiento)
        // Helechos brillantes
        const fernGeo = new THREE.ConeGeometry(0.2, 1, 3);
        const fernMat = new THREE.MeshBasicMaterial({ color: config.neonGreen });
        const ferns = new THREE.InstancedMesh(fernGeo, fernMat, 1000);
        const dummy = new THREE.Object3D();
        
        for(let i=0; i<1000; i++) {
            dummy.position.set((Math.random()-0.5)*80, 0, (Math.random()-0.5)*80);
            dummy.scale.setScalar(0.5 + Math.random());
            dummy.rotation.set(Math.random()*0.5, Math.random()*Math.PI, Math.random()*0.5);
            dummy.updateMatrix();
            ferns.setMatrixAt(i, dummy.matrix);
        }
        scene.add(ferns);


        // D. PANELES HOLOGRÁFICOS (Tech vibe)
        const panelGeo = new THREE.PlaneGeometry(2, 1.5);
        const panelMat = new THREE.MeshBasicMaterial({ 
            map: holoTexture, 
            transparent: true, 
            opacity: 0.8,
            color: config.neonCyan,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        
        const panels = [];
        for(let i=0; i<5; i++){
            const panel = new THREE.Mesh(panelGeo, panelMat);
            panel.position.set((Math.random()-0.5)*20, 0.8, (Math.random()-0.5)*10 + 5);
            panel.lookAt(0, 1, 0); // Mirar al centro (más o menos)
            scene.add(panel);
            panels.push(panel);
        }

        // E. MARIPOSAS (Partículas simples animadas)
        const butterflyCount = 50;
        const butterflyGeo = new THREE.BufferGeometry();
        const bPos = [];
        const bSpeed = [];
        
        for(let i=0; i<butterflyCount; i++){
            bPos.push((Math.random()-0.5)*30, Math.random()*10, (Math.random()-0.5)*30);
            bSpeed.push(Math.random()*0.02 + 0.01);
        }
        butterflyGeo.setAttribute('position', new THREE.Float32BufferAttribute(bPos, 3));
        const butterflyMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.3,
            map: (function() {
                // Textura circular suave on-the-fly
                const c = document.createElement('canvas'); c.width=32; c.height=32;
                const ctx = c.getContext('2d');
                const grad = ctx.createRadialGradient(16,16,0,16,16,16);
                grad.addColorStop(0, 'rgba(255,255,255,1)');
                grad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
                return new THREE.CanvasTexture(c);
            })(),
            transparent: true,
            blending: THREE.AdditiveBlending
        });
        const butterflies = new THREE.Points(butterflyGeo, butterflyMat);
        scene.add(butterflies);

        // --- 4. ILUMINACIÓN Y POST-PROCESADO ---
        const ambientLight = new THREE.AmbientLight(0x001133, 1.5); // Azul oscuro base
        scene.add(ambientLight);

        // Luz principal azulada
        const dirLight = new THREE.DirectionalLight(0x4488ff, 1);
        dirLight.position.set(-10, 20, 10);
        scene.add(dirLight);

        // Point Lights (Luces de colores locales)
        const pLight1 = new THREE.PointLight(config.neonPurple, 5, 20);
        pLight1.position.set(0, 5, -5);
        scene.add(pLight1);

        // BLOOM (EL SECRETO DE LA IMAGEN)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;   // Todo brilla un poco
        bloomPass.strength = 2.5;  // Intensidad MUY ALTA para efecto neón
        bloomPass.radius = 0.8;    // Difusión amplia
        
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 5. ANIMACIÓN ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // No ver debajo del suelo

        const clock = new THREE.Clock();
        document.getElementById('loader').style.display = 'none';

        function animate() {
            const time = clock.getElapsedTime();

            // Animar Mariposas
            const positions = butterflies.geometry.attributes.position.array;
            for(let i=0; i<butterflyCount; i++){
                const idx = i*3;
                positions[idx+1] += Math.sin(time * 2 + i) * 0.02; // Flotar arriba/abajo
                positions[idx] += Math.cos(time * 0.5 + i) * 0.02; // Mover en X
                // Reset si bajan mucho
                if(positions[idx+1] < 0) positions[idx+1] = 10;
            }
            butterflies.geometry.attributes.position.needsUpdate = true;

            // Animar Paneles (Flotar)
            panels.forEach((p, i) => {
                p.position.y = 0.8 + Math.sin(time + i) * 0.1;
            });

            // "Latido" de la luz
            pLight1.intensity = 4 + Math.sin(time * 2) * 2;

            controls.update();
            composer.render();
            requestAnimationFrame(animate);
        }

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
