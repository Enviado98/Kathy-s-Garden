<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kathy's Garden | Mobile Experience</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #0b0b14; 
            touch-action: none; /* Previene scroll nativo del celular */
        }
        
        /* UI SUPERIOR */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            padding: 40px 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        h1 {
            font-family: 'Courier New', sans-serif; /* Fallback */
            font-size: 3rem;
            color: transparent;
            -webkit-text-stroke: 1px rgba(255,255,255,0.8);
            text-shadow: 0 0 10px rgba(180, 100, 255, 0.5);
            margin: 0;
            text-transform: uppercase;
            font-weight: 900;
            letter-spacing: 2px;
        }

        .hint {
            font-family: sans-serif;
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.8rem;
            letter-spacing: 2px;
            text-transform: uppercase;
            animation: fadeUp 2s infinite;
            background: rgba(0,0,0,0.3);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
        }

        /* Cargador */
        #loader {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #00d2ff;
            font-family: monospace;
            font-size: 1.2rem;
            z-index: 20;
            transition: opacity 0.5s;
        }

        @keyframes fadeUp {
            0%, 100% { opacity: 0.4; transform: translateY(0); }
            50% { opacity: 1; transform: translateY(-5px); }
        }

        /* Fuentes Web */
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap');
        h1 { font-family: 'Cinzel', serif; }
    </style>

    <!-- IMPORT MAP PARA CARGAR THREE.JS SIN NPM -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <h1>Kathy's<br><span style="font-size:1.5rem; color:#d4aaff; -webkit-text-stroke:0;">Garden</span></h1>
        <div class="hint">◆ Arrastra para girar ◆</div>
    </div>

    <div id="loader">Cargando Magia...</div>

    <!-- CANVAS ENGINE -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURACIÓN OPTIMIZADA ---
        const config = {
            bgColor: 0x0b0b14,
            islandColor: 0x1a1a2e,
            accentColor: 0x00ffcc,
            bloomStrength: 1.2,
            bloomRadius: 0.5,
            bloomThreshold: 0.1
        };

        // 1. ESCENA BASE
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(config.bgColor);
        scene.fog = new THREE.FogExp2(config.bgColor, 0.04); // Niebla para fundir bordes

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 14); // Ángulo isométrico/juego

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limitar pixel ratio para batería
        renderer.shadowMap.enabled = true; // Sombras activadas
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // 2. CONTROLES TÁCTILES (OrbitControls)
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; // Inercia suave
        controls.dampingFactor = 0.05;
        controls.autoRotate = true; // Gira solo al principio
        controls.autoRotateSpeed = 0.8;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // No dejar ver por debajo del suelo
        controls.minDistance = 5;
        controls.maxDistance = 20;

        // 3. POST-PROCESADO (BLOOM PARA EFECTO MÁGICO)
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = config.bloomThreshold;
        bloomPass.strength = config.bloomStrength;
        bloomPass.radius = config.bloomRadius;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 4. CONSTRUCCIÓN DEL MUNDO (LA ISLA)
        
        // Grupo principal que flotará
        const islandGroup = new THREE.Group();
        scene.add(islandGroup);

        // Suelo de la isla
        const islandGeo = new THREE.CylinderGeometry(5, 3, 2, 7, 1);
        const islandMat = new THREE.MeshStandardMaterial({ 
            color: config.islandColor, 
            flatShading: true, // Estilo Low Poly
            roughness: 0.8 
        });
        const island = new THREE.Mesh(islandGeo, islandMat);
        island.receiveShadow = true;
        islandGroup.add(island);

        // Generador de Césped Optimizado (InstancedMesh)
        // Esto permite dibujar 800 hierbas como si fuera 1 solo objeto
        const grassCount = 800;
        const grassGeo = new THREE.ConeGeometry(0.1, 0.5, 3);
        const grassMat = new THREE.MeshLambertMaterial({ color: 0x2d4a5c });
        const grassMesh = new THREE.InstancedMesh(grassGeo, grassMat, grassCount);
        
        const dummy = new THREE.Object3D();
        for(let i=0; i<grassCount; i++) {
            // Posición aleatoria en círculo
            const r = Math.random() * 4.5;
            const theta = Math.random() * Math.PI * 2;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            
            dummy.position.set(x, 1, z);
            dummy.scale.setScalar(0.5 + Math.random() * 1.5); // Variedad de tamaños
            dummy.rotation.y = Math.random() * Math.PI;
            dummy.rotation.x = (Math.random() - 0.5) * 0.2; // Inclinación aleatoria
            dummy.updateMatrix();
            grassMesh.setMatrixAt(i, dummy.matrix);
        }
        grassMesh.receiveShadow = true;
        islandGroup.add(grassMesh);

        // Árbol Mágico Central (Procedural Low Poly)
        function createTree() {
            const treeGroup = new THREE.Group();

            // Tronco
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.6, 2.5, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x4a3b2a, flatShading: true });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2.25;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            // Copa del árbol (Icosaedros brillantes)
            const leavesGeo = new THREE.IcosahedronGeometry(1.2, 0);
            const leavesMat = new THREE.MeshStandardMaterial({ 
                color: 0xff00aa, // Magenta
                emissive: 0xaa0044, // Brillo propio
                emissiveIntensity: 0.5,
                flatShading: true 
            });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 3.5;
            leaves.castShadow = true;
            treeGroup.add(leaves);

            // Pequeñas hojas flotantes alrededor
            const smallLeavesGeo = new THREE.IcosahedronGeometry(0.4, 0);
            for(let i=0; i<5; i++){
                const sl = new THREE.Mesh(smallLeavesGeo, leavesMat);
                sl.position.set(
                    (Math.random()-0.5)*2,
                    3 + Math.random()*1.5,
                    (Math.random()-0.5)*2
                );
                treeGroup.add(sl);
            }

            return treeGroup;
        }
        const heroTree = createTree();
        islandGroup.add(heroTree);


        // Cristales / Flores Brillantes (Point Lights disimuladas)
        const crystalGeo = new THREE.OctahedronGeometry(0.2, 0);
        const crystalMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        
        for(let i=0; i<8; i++){
            const crystal = new THREE.Mesh(crystalGeo, crystalMat);
            const r = 2 + Math.random() * 2;
            const theta = Math.random() * Math.PI * 2;
            crystal.position.set(r * Math.cos(theta), 1.2, r * Math.sin(theta));
            islandGroup.add(crystal);
        }

        // 5. ILUMINACIÓN
        const ambientLight = new THREE.AmbientLight(0x404040, 1.5); // Luz base
        scene.add(ambientLight);

        // Luz principal (Luna)
        const dirLight = new THREE.DirectionalLight(0xaaccff, 2);
        dirLight.position.set(-5, 10, 5);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 1024; // Calidad de sombra aceptable para móvil
        dirLight.shadow.mapSize.height = 1024;
        scene.add(dirLight);

        // Luz mágica del árbol
        const treeLight = new THREE.PointLight(0xff00aa, 3, 8);
        treeLight.position.set(0, 3, 0);
        islandGroup.add(treeLight);


        // 6. SISTEMA DE PARTÍCULAS (Luciérnagas que rodean la isla)
        const particlesCount = 100;
        const posArray = new Float32Array(particlesCount * 3);
        
        for(let i=0; i<particlesCount * 3; i+=3) {
            // Esfera alrededor de la isla
            const r = 4 + Math.random() * 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI; // Esfera completa

            posArray[i] = r * Math.sin(phi) * Math.cos(theta);
            posArray[i+1] = r * Math.sin(phi) * Math.sin(theta) + 2; // Offset Y
            posArray[i+2] = r * Math.cos(phi);
        }

        const particlesGeo = new THREE.BufferGeometry();
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const particlesMat = new THREE.PointsMaterial({
            size: 0.15,
            color: 0xffd700, // Dorado
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });
        const fireflies = new THREE.Points(particlesGeo, particlesMat);
        scene.add(fireflies);


        // 7. ANIMACIÓN
        const clock = new THREE.Clock();
        
        // Ocultar loader
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').remove(), 500);

        function animate() {
            const time = clock.getElapsedTime();

            // Flotación de la isla (Seno)
            islandGroup.position.y = Math.sin(time * 0.5) * 0.3;

            // Rotación suave de partículas
            fireflies.rotation.y = time * 0.05;

            // Si el usuario toca, desactivamos la rotación automática para que tenga control
            controls.update();

            // Renderizar usando el Composer (con Bloom)
            composer.render();
            requestAnimationFrame(animate);
        }

        // Eventos táctiles para detener rotación automática
        renderer.domElement.addEventListener('touchstart', () => {
            controls.autoRotate = false;
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>
