<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Organic Life AI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        /* --- 1. CORE & RESET (Anti-Zoom Militar) --- */
        :root {
            --bg-color: #e8e8f0;
            --purple: #6200ea;
            --black: #1a1a1a;
            --yellow: #ffd600;
            --orange: #ff6d00;
            --skin-shadow: rgba(0,0,0,0.15);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        
        html, body {
            width: 100%; height: 100%; margin: 0; padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: monospace;
            touch-action: none; /* Bloqueo total de gestos */
            user-select: none;
            cursor: pointer;
        }

        /* --- 2. ESCENARIO (El Grupo) --- */
        #stage {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -40%); /* Un poco más arriba para dejar espacio */
            width: 300px; height: 300px;
            /* Debug: border: 1px solid red; */
        }

        /* --- 3. ENTIDADES --- */
        .char-container {
            position: absolute;
            will-change: transform;
            transition: z-index 0s; /* Z-index instantáneo */
        }

        .body {
            position: relative;
            transform-origin: bottom center;
            box-shadow: 0 10px 25px var(--skin-shadow);
            overflow: hidden; /* Máscara para la cara */
            transition: background 0.2s;
        }

        /* Capa de la cara (se mueve independientemente para efecto 3D falso) */
        .face-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        /* Ojos complejos */
        .eye-socket {
            position: absolute;
            background: white;
            border-radius: 50%;
            overflow: hidden;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
        }

        .pupil {
            position: absolute;
            background: #000;
            border-radius: 50%;
            width: 40%; height: 40%;
            top: 30%; left: 30%;
            will-change: transform;
        }

        .eyelid-top, .eyelid-bottom {
            position: absolute;
            width: 100%; height: 0%;
            background: inherit; /* Toma el color del padre */
            z-index: 10;
            transition: height 0.1s ease-out;
        }
        .eyelid-top { top: 0; }
        .eyelid-bottom { bottom: 0; }

        .mouth {
            position: absolute;
            background: #222;
            border-radius: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Accesorios / Partículas */
        .particle {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
        }

        .spit {
            background: rgba(200, 240, 255, 0.9);
            border: 1px solid rgba(150, 200, 255, 0.5);
            border-radius: 50%;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .sweat {
            background: #00d2ff;
            border-radius: 0 50% 50% 50%;
            transform: rotate(45deg);
        }

        /* --- 4. DISEÑOS ESPECÍFICOS (El Grupo Compacto) --- */

        /* MORADO: Atrás Izquierda (El Líder) */
        #char-purple {
            left: 20px; bottom: 80px; z-index: 10;
        }
        #char-purple .body {
            width: 100px; height: 180px;
            background: var(--purple);
            border-radius: 10px 10px 40px 40px;
        }
        #char-purple .eye-socket { width: 22px; height: 22px; }
        #char-purple .mouth { width: 20px; height: 4px; top: 100px; }

        /* NEGRO: Atrás Derecha (El Hater) */
        #char-black {
            right: 20px; bottom: 70px; z-index: 11;
        }
        #char-black .body {
            width: 90px; height: 150px;
            background: var(--black);
            border-radius: 12px;
        }
        #char-black .eye-socket { width: 18px; height: 18px; background: #fff; }
        #char-black .mouth { width: 15px; height: 2px; top: 80px; background: #888; }

        /* NARANJA: Frente Izquierda (El Tonto) */
        #char-orange {
            left: -10px; bottom: 0; z-index: 20;
        }
        #char-orange .body {
            width: 130px; height: 100px;
            background: var(--orange);
            border-radius: 60px 60px 20px 20px;
        }
        #char-orange .eye-socket { width: 16px; height: 16px; }
        #char-orange .mouth { width: 25px; height: 10px; top: 55px; border-radius: 0 0 20px 20px; }

        /* AMARILLO: Frente Derecha (El Miedoso) */
        #char-yellow {
            right: 0; bottom: 0; z-index: 21;
        }
        #char-yellow .body {
            width: 90px; height: 110px;
            background: var(--yellow);
            border-radius: 45px 45px 0 0;
        }
        #char-yellow .eye-socket { width: 12px; height: 12px; }
        #char-yellow .mouth { width: 10px; height: 3px; top: 60px; }

    </style>
</head>
<body>

    <div id="stage"></div>

<script>
/**
 * ------------------------------------------------------------------
 * MOTOR DE VIDA ORGÁNICA v2.0
 * ------------------------------------------------------------------
 * Características:
 * - Sistema de Atención Vectorial (Ojos con física)
 * - Máquina de Estados de Agresión
 * - Partículas de HTML (Escupitajos, Sudor)
 * - Loops de Comportamiento Asíncronos
 */

// --- UTILIDADES MATEMÁTICAS ---
const MathUtils = {
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    clamp: (val, min, max) => Math.min(Math.max(val, min), max),
    rand: (min, max) => Math.random() * (max - min) + min,
    randInt: (min, max) => Math.floor(Math.random() * (max - min + 1) + min)
};

// --- CONFIGURACIÓN GLOBAL ---
const CONFIG = {
    eyeDamping: 0.1, // Suavidad de ojos (menor = más arrastre)
    blinkMin: 2000,
    blinkMax: 6000,
    talkSpeed: 0.15,
    aggressionDecay: 0.05, // Cuánto baja el enojo por frame si no tocas
    maxAggression: 100,
    spitChance: 0.8 // Probabilidad de escupitajo en furia máxima
};

// --- CLASE: SISTEMA DE OJOS ---
class EyeSystem {
    constructor(el, xOffset, yOffset, size) {
        this.el = document.createElement('div');
        this.el.className = 'eye-socket';
        this.el.style.left = xOffset + 'px';
        this.el.style.top = yOffset + 'px';
        
        // Estructura interna
        this.pupil = document.createElement('div');
        this.pupil.className = 'pupil';
        
        this.lidTop = document.createElement('div');
        this.lidTop.className = 'eyelid-top';
        this.lidBottom = document.createElement('div');
        this.lidBottom.className = 'eyelid-bottom';

        this.el.appendChild(this.pupil);
        this.el.appendChild(this.lidTop);
        this.el.appendChild(this.lidBottom);

        // Física
        this.targetX = 0; this.targetY = 0;
        this.currentX = 0; this.currentY = 0;
        this.range = size / 2.5; // Rango de movimiento dentro del ojo
    }

    // Actualiza posición de pupila con interpolación (suavidad)
    update() {
        this.currentX = MathUtils.lerp(this.currentX, this.targetX, CONFIG.eyeDamping);
        this.currentY = MathUtils.lerp(this.currentY, this.targetY, CONFIG.eyeDamping);
        
        this.pupil.style.transform = `translate(${this.currentX}px, ${this.currentY}px)`;
    }

    lookAt(relX, relY) {
        // relX/relY deben ser valores entre -1 y 1
        this.targetX = MathUtils.clamp(relX, -1, 1) * this.range;
        this.targetY = MathUtils.clamp(relY, -1, 1) * this.range;
    }

    blink(duration = 0.15) {
        gsap.to([this.lidTop, this.lidBottom], { height: '55%', duration: 0.1, yoyo: true, repeat: 1 });
    }

    express(type) {
        gsap.killTweensOf([this.lidTop, this.lidBottom]);
        if(type === 'angry') {
            gsap.to(this.lidTop, { height: '45%', duration: 0.3 });
            gsap.to(this.lidBottom, { height: '20%', duration: 0.3 });
        } else if (type === 'suspicious') {
            gsap.to(this.lidTop, { height: '30%', duration: 0.3 });
            gsap.to(this.lidBottom, { height: '30%', duration: 0.3 });
        } else if (type === 'scared') {
            gsap.to([this.lidTop, this.lidBottom], { height: '0%', duration: 0.1 }); // Ojos muy abiertos
        } else if (type === 'bored') {
            gsap.to(this.lidTop, { height: '40%', duration: 0.5 });
            gsap.to(this.lidBottom, { height: '0%', duration: 0.5 });
        } else {
            // Neutral
            gsap.to([this.lidTop, this.lidBottom], { height: '0%', duration: 0.3 });
        }
    }
}

// --- CLASE: PERSONAJE ---
class Character {
    constructor(id, color, type, config) {
        this.id = id;
        this.type = type; // 'leader', 'hater', 'dumb', 'scared'
        this.config = config; // {x, y, w, h, eyePos}
        
        this.isTalking = false;
        this.attention = { x: 0, y: 0 }; // Dónde está mirando (-1 a 1)
        this.baseScale = 1;

        this.dom = this.createDOM(color);
        this.eyes = [];
        this.setupEyes();
        
        // Ciclos de vida
        this.startBreathing();
        this.blinkLoop();
    }

    createDOM(color) {
        const container = document.createElement('div');
        container.className = 'char-container';
        container.id = `char-${this.id}`;

        const body = document.createElement('div');
        body.className = 'body';
        
        // Capa de cara
        this.faceLayer = document.createElement('div');
        this.faceLayer.className = 'face-layer';

        this.mouth = document.createElement('div');
        this.mouth.className = 'mouth';

        this.faceLayer.appendChild(this.mouth);
        body.appendChild(this.faceLayer);
        container.appendChild(body);
        
        // Evento de toque INDIVIDUAL
        container.addEventListener('pointerdown', (e) => {
            e.stopPropagation(); // Evita que el "mundo" lo detecte
            World.handleEntityTouch(this);
        });

        document.getElementById('stage').appendChild(container);
        return { container, body, face: this.faceLayer };
    }

    setupEyes() {
        const spacing = this.id === 'purple' ? 26 : (this.id === 'orange' ? 30 : 22);
        const yPos = this.config.eyeY;
        const xCenter = parseInt(getComputedStyle(this.dom.body).width) / 2;
        const size = this.id === 'purple' ? 22 : (this.id === 'orange' ? 16 : (this.id === 'black' ? 18 : 12));

        // Ojo Izquierdo
        const leftEye = new EyeSystem(this.dom.face, xCenter - spacing/2 - size/2, yPos, size);
        const rightEye = new EyeSystem(this.dom.face, xCenter + spacing/2 - size/2, yPos, size);
        
        this.dom.face.appendChild(leftEye.el);
        this.dom.face.appendChild(rightEye.el);
        this.eyes = [leftEye, rightEye];
    }

    // --- LOGICA DE COMPORTAMIENTO ---

    update() {
        // 1. Actualizar ojos
        this.eyes.forEach(eye => {
            // Los ojos miran a la "atención" global del personaje + ruido
            eye.lookAt(this.attention.x, this.attention.y);
            eye.update();
        });
    }

    setAttention(x, y, speed = 1) {
        // Interpolamos la atención del personaje para que no gire la cabeza de golpe
        // Nota: Aquí simulamos que gira los ojos primero, luego la cara
        gsap.to(this.attention, { x: x, y: y, duration: 0.5 / speed });

        // Mover la capa de la cara (Parallax)
        const faceMoveX = x * 10; 
        const faceMoveY = y * 5;
        gsap.to(this.dom.face, { x: faceMoveX, y: faceMoveY, duration: 0.8 / speed, ease: "power2.out" });
    }

    setMood(mood) {
        this.eyes.forEach(e => e.express(mood));
        
        // Boca según mood
        if(mood === 'angry') {
            gsap.to(this.mouth, { width: 15, height: 2, borderRadius: 0, duration: 0.3 });
        } else if (mood === 'surprise') {
            gsap.to(this.mouth, { width: 10, height: 10, borderRadius: '50%', duration: 0.2 });
        } else if (mood === 'talking') {
            // (Manejado por talk())
        } else {
            // Neutral
            const w = this.id === 'orange' ? 25 : 15;
            const h = this.id === 'orange' ? 10 : (this.id === 'purple' ? 4 : 2);
            gsap.to(this.mouth, { width: w, height: h, borderRadius: '0 0 10px 10px', duration: 0.4 });
        }
    }

    talk() {
        if(this.isTalking) return;
        this.isTalking = true;
        
        this.talkAnim = gsap.to(this.mouth, {
            height: () => MathUtils.rand(4, 12),
            width: () => MathUtils.rand(10, 20),
            duration: 0.15,
            repeat: -1,
            yoyo: true
        });

        // Rebote del cuerpo al hablar
        this.bodyTalkAnim = gsap.to(this.dom.body, {
            rotation: () => MathUtils.rand(-2, 2),
            y: "+=2",
            duration: 0.2,
            repeat: -1,
            yoyo: true
        });
    }

    stopTalking() {
        this.isTalking = false;
        if(this.talkAnim) this.talkAnim.kill();
        if(this.bodyTalkAnim) this.bodyTalkAnim.kill();
        gsap.to(this.dom.body, { rotation: 0, y: 0, duration: 0.3 });
        this.setMood(this.mood || 'neutral');
    }

    // --- ACCIONES ESPECIALES (Reacciones al toque) ---

    freakOut() {
        // Para el Amarillo (Miedoso)
        this.setMood('scared');
        gsap.to(this.dom.body, { scale: 0.8, y: 20, duration: 0.2, yoyo: true, repeat: 3 });
        this.createSweat();
    }

    getAngry() {
        // Para el Morado (Lider)
        this.setMood('angry');
        gsap.to(this.dom.body, { scale: 1.1, duration: 0.2, yoyo: true, repeat: 1 });
    }

    actDumb() {
        // Para el Naranja (Tonto)
        this.setMood('surprise');
        this.eyes[0].lookAt(-0.8, -0.5); // Ojos bizcos
        this.eyes[1].lookAt(0.8, 0.5);
        gsap.to(this.dom.body, { rotation: 10, duration: 0.5, ease: "elastic.out(1, 0.3)" });
        setTimeout(() => gsap.to(this.dom.body, { rotation: 0, duration: 0.5 }), 1000);
    }

    spitAtCamera() {
        // Para el Negro (Hater) - LA FUNCIÓN PRO
        this.setMood('angry');
        
        // 1. Animación de "Cargar" escupitajo (hacia atrás)
        gsap.to(this.dom.body, { scale: 0.9, y: 10, duration: 0.3 });

        // 2. Disparar
        setTimeout(() => {
            gsap.to(this.dom.body, { scale: 1.05, y: -5, duration: 0.1, onComplete: () => {
                gsap.to(this.dom.body, { scale: 1, y: 0, duration: 0.3 });
            }});

            // Crear partícula de escupitajo
            const spit = document.createElement('div');
            spit.className = 'particle spit';
            
            // Posición inicial (la boca del personaje)
            const rect = this.mouth.getBoundingClientRect();
            spit.style.left = (rect.left + rect.width/2) + 'px';
            spit.style.top = (rect.top + rect.height/2) + 'px';
            spit.style.width = '10px'; spit.style.height = '10px';
            document.body.appendChild(spit);

            // Trayectoria hacia la "cámara" (Centro de pantalla y grande)
            gsap.to(spit, {
                left: window.innerWidth / 2 + MathUtils.rand(-50, 50),
                top: window.innerHeight / 2 + MathUtils.rand(-50, 50),
                width: 100, // Se hace grande al acercarse
                height: 100,
                opacity: 0.8,
                duration: 0.4,
                ease: "power2.in",
                onComplete: () => {
                    // 3. Efecto de "Pegarse" en la pantalla
                    spit.style.borderRadius = "40% 60% 30% 70% / 50% 30% 70% 50%"; // Forma irregular orgánica
                    
                    // Resbalar lentamente
                    gsap.to(spit, { y: "+=50", opacity: 0, duration: 3, delay: 0.5, onComplete: () => spit.remove() });
                }
            });

        }, 300);
    }

    createSweat() {
        const sweat = document.createElement('div');
        sweat.className = 'particle sweat';
        const rect = this.dom.body.getBoundingClientRect();
        sweat.style.left = (rect.right - 20) + 'px';
        sweat.style.top = rect.top + 'px';
        sweat.style.width = '10px'; sweat.style.height = '15px';
        document.body.appendChild(sweat);

        gsap.to(sweat, { y: -20, opacity: 1, duration: 0.3 });
        gsap.to(sweat, { y: 20, opacity: 0, duration: 0.8, delay: 0.3, onComplete: () => sweat.remove() });
    }

    // --- CICLOS INTERNOS ---
    startBreathing() {
        const rate = MathUtils.rand(1.5, 3);
        gsap.to(this.dom.body, {
            scaleY: 1.02, scaleX: 0.99,
            duration: rate,
            yoyo: true, repeat: -1, ease: "sine.inOut",
            delay: MathUtils.rand(0, 1)
        });
    }

    blinkLoop() {
        const next = MathUtils.rand(CONFIG.blinkMin, CONFIG.blinkMax);
        setTimeout(() => {
            if(this.mood !== 'angry') this.eyes.forEach(e => e.blink());
            this.blinkLoop();
        }, next);
    }
}

// --- CLASE: MUNDO (EL CEREBRO GLOBAL) ---
const World = {
    chars: [],
    state: 'GOSSIP', // GOSSIP, JUDGING, SILENCE
    aggressionLevel: 0,
    maxAggression: 5,
    touchCount: 0,
    lastTouchTime: 0,
    gossipTimer: null,
    decayTimer: null,

    init() {
        // Crear personajes
        this.chars.push(new Character('purple', null, 'leader', { eyeY: 60 }));
        this.chars.push(new Character('black', null, 'hater', { eyeY: 50 }));
        this.chars.push(new Character('orange', null, 'dumb', { eyeY: 35 }));
        this.chars.push(new Character('yellow', null, 'scared', { eyeY: 40 }));
        
        this.startLoop();
        this.setupInput();
        this.startGossipCycle();
        this.startAggressionDecay();
    },

    setupInput() {
        // Listener global (Toque al fondo)
        document.addEventListener('pointerdown', (e) => {
            // Si el toque fue en un personaje, no cuenta como toque de fondo
            if(e.target.closest('.char-container')) return;
            
            this.handleGlobalTouch(e.clientX, e.clientY);
        });
    },

    startLoop() {
        const loop = () => {
            this.chars.forEach(c => c.update());
            requestAnimationFrame(loop);
        };
        loop();
    },

    // --- IA DE CONVERSACIÓN ---
    startGossipCycle() {
        const nextGossip = () => {
            if(this.state === 'JUDGING') return; // Si están juzgando, no hablan

            // Reiniciar estado
            this.chars.forEach(c => c.stopTalking());

            // Decidir acción
            const r = Math.random();
            
            if(r < 0.7) {
                // ALGUIEN HABLA
                const speaker = this.chars[MathUtils.randInt(0, 3)];
                speaker.talk();
                speaker.setAttention(0, 0.5); // Mira al "centro" del grupo

                // Los demás miran al hablante
                const sRect = speaker.dom.body.getBoundingClientRect();
                const sX = sRect.left + sRect.width/2;
                const sY = sRect.top + 30;

                this.chars.forEach(c => {
                    if(c !== speaker) {
                        // Calcular vector normalizado hacia el hablante
                        const cRect = c.dom.body.getBoundingClientRect();
                        const dx = (sX - (cRect.left + cRect.width/2)) / 200;
                        const dy = (sY - (cRect.top + cRect.height/2)) / 200;
                        c.setAttention(dx, dy);
                        c.setMood('neutral');
                    }
                });

            } else {
                // SILENCIO INCÓMODO O MIRADA ALEATORIA
                this.chars.forEach(c => {
                    c.setAttention(MathUtils.rand(-1, 1), MathUtils.rand(-0.5, 0.5));
                    if(Math.random() > 0.8) c.setMood('bored');
                });
            }

            // Ocurrencias aleatorias durante el chisme ("Side Eye")
            if (this.aggressionLevel > 0 && Math.random() > 0.6) {
                // Si están un poco molestos, uno vigila al usuario
                const watcher = this.chars[MathUtils.randInt(0, 3)];
                setTimeout(() => {
                   if(this.state !== 'JUDGING') {
                       watcher.setAttention(0, 0); // Mira hacia "adelante" (usuario)
                       watcher.setMood('suspicious');
                   }
                }, 500);
            }

            this.gossipTimer = setTimeout(nextGossip, MathUtils.rand(1500, 4000));
        };
        nextGossip();
    },

    // --- IA DE AGRESIÓN (EL REQUERIMIENTO PRINCIPAL) ---
    
    handleGlobalTouch(x, y) {
        const now = Date.now();
        // Si tocas muy rápido, sube más rápido la agresión
        const spamBonus = (now - this.lastTouchTime < 300) ? 2 : 1;
        this.touchCount += spamBonus;
        this.aggressionLevel = Math.min(this.aggressionLevel + spamBonus, 10);
        this.lastTouchTime = now;

        console.log("Aggression:", this.aggressionLevel);

        this.reactToAggression();
    },

    reactToAggression() {
        // NIVELES DE REACCIÓN
        
        // NIVEL 1: MOLESTIA LEVE (1-3 toques)
        if (this.aggressionLevel > 0 && this.aggressionLevel < 4) {
            // Uno aleatorio te mira mal
            const observer = this.chars[MathUtils.randInt(0, 3)];
            observer.stopTalking(); // Se calla
            observer.setAttention(0, 0, 2); // Mira rápido a cámara
            observer.setMood('suspicious');
            
            // Los otros siguen a lo suyo pero se nota tensión
        }
        
        // NIVEL 2: SILENCIO Y JUICIO (4-7 toques)
        else if (this.aggressionLevel >= 4 && this.aggressionLevel < 8) {
            this.state = 'JUDGING';
            clearTimeout(this.gossipTimer); // Cortar chisme
            
            this.chars.forEach((c, i) => {
                c.stopTalking();
                // Reacción en cadena, no todos a la vez
                setTimeout(() => {
                    c.setAttention(0, 0, 1.5); // Todos miran al frente
                    c.setMood('bored'); // Cara de "¿En serio?"
                }, i * 100);
            });
        }

        // NIVEL 3: FURIA TOTAL / ESCUPITAJO (8+ toques)
        else if (this.aggressionLevel >= 8) {
            this.state = 'JUDGING';
            
            this.chars.forEach(c => {
                c.stopTalking();
                c.setAttention(0, 0, 5); // Mirada clavada instantánea
                c.setMood('angry');
                
                // Efecto de "Venir hacia ti"
                gsap.to(c.dom.body, { scale: 1.1, duration: 0.2 });
            });

            // EL HATER (Negro) TE ESCUPE SI TIENES MALA SUERTE
            const hater = this.chars.find(c => c.id === 'black');
            if (hater && Math.random() < CONFIG.spitChance) {
                hater.spitAtCamera();
                this.aggressionLevel = 0; // Resetear tras el clímax para que no escupa infinito
                setTimeout(() => this.resetState(), 4000); // Tardan más en recuperarse
                return;
            }
        }
    },

    handleEntityTouch(char) {
        // REACCIONES A TOQUES INDIVIDUALES (FÍSICOS)
        // Esto interrumpe todo y genera caos
        this.state = 'CHAOS';
        clearTimeout(this.gossipTimer);
        this.lastTouchTime = Date.now(); // Resetea decay

        // 1. Reacción del tocado
        if (char.id === 'yellow') char.freakOut();
        else if (char.id === 'purple') char.getAngry();
        else if (char.id === 'orange') char.actDumb();
        else if (char.id === 'black') {
             // El negro tiene mal genio instantáneo
             char.spitAtCamera();
             this.resetStateAfter(3000);
             return;
        }

        // 2. Reacción de los otros (miran al que fue tocado)
        this.chars.forEach(c => {
            if(c !== char) {
                // Miran al compañero
                const tRect = char.dom.body.getBoundingClientRect();
                const myRect = c.dom.body.getBoundingClientRect();
                const dx = (tRect.left - myRect.left) / 200;
                const dy = (tRect.top - myRect.top) / 200;
                
                c.stopTalking();
                c.setAttention(dx, dy, 2);
                c.setMood('surprise');
            }
        });

        this.resetStateAfter(2000);
    },

    resetStateAfter(ms) {
        setTimeout(() => this.resetState(), ms);
    },

    resetState() {
        this.state = 'GOSSIP';
        this.aggressionLevel = Math.max(0, this.aggressionLevel - 5); // Bajar enojo
        
        // Volver a tamaño normal
        this.chars.forEach(c => {
            gsap.to(c.dom.body, { scale: 1, duration: 0.5 });
        });
        
        this.startGossipCycle();
    },

    startAggressionDecay() {
        // Si no tocas la pantalla, se les pasa el enojo poco a poco
        setInterval(() => {
            if (this.aggressionLevel > 0 && Date.now() - this.lastTouchTime > 1000) {
                this.aggressionLevel -= 1;
                if(this.aggressionLevel <= 0) {
                    this.aggressionLevel = 0;
                    if(this.state === 'JUDGING') this.resetState();
                }
            }
        }, 1000);
    }
};

// --- INICIO ---
window.onload = () => World.init();

</script>
</body>
</html>
